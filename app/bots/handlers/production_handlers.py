from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from app.security.auth import security
from app.database.supabase import supabase
from app.decorators.conversation_logging import log_production_conversation, log_unauthorized_access
import logging

logger = logging.getLogger(__name__)

class ProductionHandlers:
    """Manejadores para el bot de producci√≥n"""
    
    @staticmethod
    @log_production_conversation
    async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando de inicio para el bot de producci√≥n"""
        chat_id = update.effective_chat.id
        
        # Validar usuario
        validation = security.validate_user(chat_id)
        
        if not validation['valid']:
            # Registrar usuario no autorizado antes de responder
            await ProductionHandlers._handle_unauthorized_user(update, context)
            return
        
        user_data = validation['user_data']
        
        # El logging ahora es autom√°tico con el decorador
        await ProductionHandlers._show_main_menu(update.message, user_data)
    
    @staticmethod
    async def _show_main_menu(message_or_query, user_data):
        """Mostrar men√∫ principal con los 6 botones"""
        keyboard = [
            [
                InlineKeyboardButton("üìä Informaci√≥n", callback_data="informacion"),
                InlineKeyboardButton("‚è≥ Pendientes", callback_data="pendientes")
            ],
            [
                InlineKeyboardButton("üí∞ CxC & CxP", callback_data="cxc_cxp"),
                InlineKeyboardButton("ü§ñ Asesor IA", callback_data="asesor_ia")
            ],
            [
                InlineKeyboardButton("üìÖ Agendar", callback_data="agendar"),
                InlineKeyboardButton("‚ÑπÔ∏è Ayuda", callback_data="ayuda")
            ],
            [InlineKeyboardButton("üö™ Salir", callback_data="salir")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        text = f"üëã **Bienvenido {user_data.get('nombre', 'Usuario')}**\n\nSelecciona una opci√≥n del men√∫:"
        
        # Si es un CallbackQuery, usar edit_message_text
        if hasattr(message_or_query, 'edit_message_text'):
            await message_or_query.edit_message_text(
                text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        # Si es un Message, usar reply_text
        else:
            await message_or_query.reply_text(
                text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
    
    @staticmethod
    async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manejar callbacks del bot de producci√≥n"""
        query = update.callback_query
        await query.answer()
        
        chat_id = update.effective_chat.id
        
        # Validar usuario en cada callback
        validation = security.validate_user(chat_id)
        
        if not validation['valid']:
            await query.edit_message_text(validation['message'])
            return
        
        user_data = validation['user_data']
        
        # Log de la acci√≥n (deshabilitado temporalmente por RLS)
        # try:
        #     supabase.log_conversation(
        #         chat_id=chat_id,
        #         empresa_id=user_data['empresa_id'],
        #         mensaje=f"Callback: {query.data}",
        #         respuesta="Procesando solicitud"
        #     )
        # except Exception as e:
        #     logger.warning(f"Error en logging (RLS): {e}")
        pass
        
        # Manejar diferentes opciones
        if query.data == "informacion":
            await ProductionHandlers._handle_informacion(query, user_data)
        elif query.data == "pendientes":
            await ProductionHandlers._handle_pendientes(query, user_data)
        elif query.data == "cxc_cxp":
            await ProductionHandlers._handle_cxc_cxp(query, user_data)
        elif query.data == "asesor_ia":
            await ProductionHandlers._handle_asesor_ia(query, user_data)
        elif query.data == "agendar":
            await ProductionHandlers._handle_agendar(query, user_data)
        elif query.data == "ayuda":
            await ProductionHandlers._handle_ayuda(query, user_data)
        elif query.data == "salir":
            await ProductionHandlers._handle_salir(query)
        elif query.data == "back_main":
            await ProductionHandlers._show_main_menu(query, user_data)
        elif query.data == "reportes":
            await ProductionHandlers._handle_reportes(query, user_data)
        elif query.data == "info_compania":
            await ProductionHandlers._handle_info_compania(query, user_data)
        elif query.data.startswith("mes_"):
            await ProductionHandlers._handle_mes_reporte(query, user_data)
        elif query.data.startswith("categoria_"):
            await ProductionHandlers._handle_categoria_info(query, user_data)
    
    @staticmethod
    async def _handle_informacion(query, user_data):
        """Manejar opci√≥n de informaci√≥n - men√∫ principal"""
        try:
            text = "üìä **Informaci√≥n de la Empresa**\n\n"
            text += "Selecciona el tipo de informaci√≥n que necesitas:"
            
            keyboard = [
                [
                    InlineKeyboardButton("üìà Reportes", callback_data="reportes"),
                    InlineKeyboardButton("üè¢ Informaci√≥n Compa√±√≠a", callback_data="info_compania")
                ],
                [InlineKeyboardButton("üîô Volver al Men√∫", callback_data="back_main")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
        except Exception as e:
            logger.error(f"Error manejando informaci√≥n: {e}")
            await query.edit_message_text("Error mostrando informaci√≥n.")
    
    @staticmethod
    async def _handle_reportes(query, user_data):
        """Manejar opci√≥n de reportes - mostrar meses del a√±o actual"""
        try:
            from datetime import datetime
            current_year = datetime.now().year
            current_month = datetime.now().month
            
            text = f"üìà **Reportes {current_year}**\n\n"
            text += "Selecciona el mes del reporte que necesitas:"
            
            # Crear botones para los meses del a√±o actual
            months = [
                ("Enero", 1), ("Febrero", 2), ("Marzo", 3), ("Abril", 4),
                ("Mayo", 5), ("Junio", 6), ("Julio", 7), ("Agosto", 8),
                ("Septiembre", 9), ("Octubre", 10), ("Noviembre", 11), ("Diciembre", 12)
            ]
            
            keyboard = []
            row = []
            for month_name, month_num in months:
                # Marcar el mes actual
                if month_num == current_month:
                    month_name = f"üìç {month_name}"
                
                row.append(InlineKeyboardButton(
                    month_name, 
                    callback_data=f"mes_{current_year}_{month_num:02d}"
                ))
                
                if len(row) == 3:  # 3 botones por fila
                    keyboard.append(row)
                    row = []
            
            if row:  # Agregar la √∫ltima fila si no est√° completa
                keyboard.append(row)
            
            keyboard.append([InlineKeyboardButton("üîô Volver", callback_data="informacion")])
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
        except Exception as e:
            logger.error(f"Error manejando reportes: {e}")
            await query.edit_message_text("Error mostrando reportes.")
    
    @staticmethod
    async def _handle_info_compania(query, user_data):
        """Manejar opci√≥n de informaci√≥n de la compa√±√≠a"""
        try:
            text = "üè¢ **Informaci√≥n de la Compa√±√≠a**\n\n"
            text += "Selecciona la categor√≠a de informaci√≥n:"
            
            keyboard = [
                [
                    InlineKeyboardButton("‚öñÔ∏è Legal", callback_data="categoria_legal"),
                    InlineKeyboardButton("üí∞ Financiera", callback_data="categoria_financiera")
                ],
                [
                    InlineKeyboardButton("üìä Tributaria", callback_data="categoria_tributaria"),
                    InlineKeyboardButton("üìÅ Carpeta Tributaria", callback_data="categoria_carpeta")
                ],
                [InlineKeyboardButton("üîô Volver", callback_data="informacion")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
        except Exception as e:
            logger.error(f"Error manejando informaci√≥n de compa√±√≠a: {e}")
            await query.edit_message_text("Error mostrando informaci√≥n de compa√±√≠a.")
    
    @staticmethod
    async def _handle_mes_reporte(query, user_data):
        """Manejar selecci√≥n de mes para reportes"""
        try:
            # Extraer a√±o y mes del callback_data (formato: mes_2024_01)
            _, year, month = query.data.split('_')
            month_name = {
                '01': 'Enero', '02': 'Febrero', '03': 'Marzo', '04': 'Abril',
                '05': 'Mayo', '06': 'Junio', '07': 'Julio', '08': 'Agosto',
                '09': 'Septiembre', '10': 'Octubre', '11': 'Noviembre', '12': 'Diciembre'
            }[month]
            
            text = f"üìà **Reporte {month_name} {year}**\n\n"
            text += f"Empresa: **{user_data.get('empresa_nombre', 'N/A')}**\n"
            text += f"Per√≠odo: {month_name} {year}\n\n"
            
            # Obtener reportes reales de la base de datos
            reportes = supabase.get_reportes_mensuales(
                empresa_id=user_data['empresa_id'],
                anio=int(year),
                mes=int(month)
            )
            
            if reportes:
                text += "üìÑ **Reportes disponibles:**\n"
                for reporte in reportes:
                    text += f"‚Ä¢ **{reporte.get('titulo', 'Sin t√≠tulo')}**\n"
                    if reporte.get('descripcion'):
                        text += f"  {reporte['descripcion']}\n"
                    if reporte.get('comentarios'):
                        text += f"  üìù {reporte['comentarios']}\n"
                    text += f"  üìä Estado: {reporte.get('estado', 'borrador')}\n\n"
                
                # Obtener archivos adjuntos
                for reporte in reportes:
                    archivos = supabase.get_archivos_reporte(reporte['id'])
                    if archivos:
                        text += f"üìé **Archivos de {reporte.get('titulo', 'reporte')}:**\n"
                        for archivo in archivos:
                            text += f"‚Ä¢ {archivo.get('nombre_archivo', 'Sin nombre')}\n"
                        text += "\n"
            else:
                text += "üìÑ **No hay reportes disponibles para este per√≠odo.**\n\n"
                text += "Puedes crear un nuevo reporte o adjuntar documentos.\n\n"
            
            keyboard = [
                [
                    InlineKeyboardButton("üìÑ Crear Reporte", callback_data=f"crear_reporte_{year}_{month}"),
                    InlineKeyboardButton("üìé Adjuntar Archivo", callback_data=f"adjuntar_{year}_{month}")
                ],
                [
                    InlineKeyboardButton("üìù Agregar Comentario", callback_data=f"comentario_{year}_{month}"),
                    InlineKeyboardButton("üìä Ver Datos", callback_data=f"datos_{year}_{month}")
                ],
                [InlineKeyboardButton("üîô Volver a Reportes", callback_data="reportes")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
        except Exception as e:
            logger.error(f"Error manejando mes de reporte: {e}")
            await query.edit_message_text("Error mostrando reporte del mes.")
    
    @staticmethod
    async def _handle_categoria_info(query, user_data):
        """Manejar categor√≠as de informaci√≥n de la compa√±√≠a"""
        try:
            categoria = query.data.split('_')[1]  # legal, financiera, tributaria, carpeta
            
            categorias = {
                'legal': {
                    'title': '‚öñÔ∏è **Informaci√≥n Legal**',
                    'icon': '‚öñÔ∏è',
                    'content': [
                        '‚Ä¢ Estatutos de la empresa',
                        '‚Ä¢ Registro mercantil',
                        '‚Ä¢ Licencias comerciales',
                        '‚Ä¢ Contratos vigentes',
                        '‚Ä¢ Propiedad intelectual'
                    ]
                },
                'financiera': {
                    'title': 'üí∞ **Informaci√≥n Financiera**',
                    'icon': 'üí∞',
                    'content': [
                        '‚Ä¢ Estados financieros',
                        '‚Ä¢ Presupuestos',
                        '‚Ä¢ Flujos de caja',
                        '‚Ä¢ An√°lisis de ratios',
                        '‚Ä¢ Proyecciones financieras'
                    ]
                },
                'tributaria': {
                    'title': 'üìä **Informaci√≥n Tributaria**',
                    'icon': 'üìä',
                    'content': [
                        '‚Ä¢ Declaraciones de impuestos',
                        '‚Ä¢ Certificados tributarios',
                        '‚Ä¢ Retenciones en la fuente',
                        '‚Ä¢ IVA y otros impuestos',
                        '‚Ä¢ Resoluciones fiscales'
                    ]
                },
                'carpeta': {
                    'title': 'üìÅ **Carpeta Tributaria**',
                    'icon': 'üìÅ',
                    'content': [
                        '‚Ä¢ Documentos de constituci√≥n',
                        '‚Ä¢ Registros contables',
                        '‚Ä¢ Comprobantes de pago',
                        '‚Ä¢ Certificados bancarios',
                        '‚Ä¢ Documentos de respaldo'
                    ]
                }
            }
            
            cat_info = categorias.get(categoria, {
                'title': 'üìã **Informaci√≥n**',
                'icon': 'üìã',
                'content': ['Informaci√≥n no disponible']
            })
            
            text = f"{cat_info['title']}\n\n"
            text += f"Empresa: **{user_data.get('empresa_nombre', 'N/A')}**\n\n"
            
            # Obtener informaci√≥n real de la base de datos
            info_compania = supabase.get_info_compania(
                empresa_id=user_data['empresa_id'],
                categoria=categoria
            )
            
            if info_compania:
                text += "üìã **Informaci√≥n disponible:**\n"
                for info in info_compania:
                    text += f"‚Ä¢ **{info.get('titulo', 'Sin t√≠tulo')}**\n"
                    if info.get('descripcion'):
                        text += f"  {info['descripcion']}\n"
                    if info.get('contenido'):
                        text += f"  {info['contenido']}\n"
                    text += "\n"
                
                # Obtener archivos adjuntos
                for info in info_compania:
                    archivos = supabase.get_archivos_info_compania(info['id'])
                    if archivos:
                        text += f"üìé **Archivos de {info.get('titulo', 'informaci√≥n')}:**\n"
                        for archivo in archivos:
                            text += f"‚Ä¢ {archivo.get('nombre_archivo', 'Sin nombre')}\n"
                        text += "\n"
            else:
                text += "üìã **No hay informaci√≥n disponible en esta categor√≠a.**\n\n"
                text += "Puedes agregar nueva informaci√≥n o adjuntar documentos.\n\n"
            
            keyboard = [
                [
                    InlineKeyboardButton("üìù Agregar Info", callback_data=f"add_{categoria}"),
                    InlineKeyboardButton("üìé Adjuntar Archivo", callback_data=f"attach_{categoria}")
                ],
                [
                    InlineKeyboardButton("üìÑ Ver Documentos", callback_data=f"docs_{categoria}"),
                    InlineKeyboardButton("üìä Exportar", callback_data=f"export_{categoria}")
                ],
                [InlineKeyboardButton("üîô Volver", callback_data="info_compania")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
        except Exception as e:
            logger.error(f"Error manejando categor√≠a de informaci√≥n: {e}")
            await query.edit_message_text("Error mostrando informaci√≥n de la categor√≠a.")
    
    @staticmethod
    async def _handle_pendientes(query, user_data):
        """Manejar opci√≥n de pendientes"""
        try:
            # Obtener pendientes de la empresa
            pendientes = supabase.get_empresa_data(user_data['empresa_id'], 'pendientes')
            
            text = "‚è≥ **Pendientes**\n\n"
            
            if pendientes:
                for pendiente in pendientes:
                    text += f"‚Ä¢ **{pendiente.get('titulo', 'Sin t√≠tulo')}**\n"
                    text += f"  üìÖ Fecha: {pendiente.get('fecha_limite', 'Sin fecha')}\n"
                    text += f"  üìù {pendiente.get('descripcion', 'Sin descripci√≥n')}\n"
                    text += f"  üè∑Ô∏è Tipo: {pendiente.get('tipo', 'General')}\n\n"
            else:
                text += "No hay pendientes registrados.\n"
            
            text += "\n*En desarrollo*"
            
            keyboard = [[InlineKeyboardButton("üîô Volver al Men√∫", callback_data="back_main")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
        except Exception as e:
            logger.error(f"Error manejando pendientes: {e}")
            await query.edit_message_text("Error obteniendo pendientes.")
    
    @staticmethod
    async def _handle_cxc_cxp(query, user_data):
        """Manejar opci√≥n de CxC y CxP"""
        try:
            # Obtener datos de CxC y CxP de la empresa
            cxc_data = supabase.get_empresa_data(user_data['empresa_id'], 'cuentas_cobrar')
            cxp_data = supabase.get_empresa_data(user_data['empresa_id'], 'cuentas_pagar')
            
            text = "üí∞ **Cuentas por Cobrar y Pagar**\n\n"
            
            # CxC
            text += "üìà **Cuentas por Cobrar:**\n"
            if cxc_data:
                total_cxc = sum(item.get('monto', 0) for item in cxc_data)
                text += f"Total: ${total_cxc:,.0f}\n"
                for cxc in cxc_data[:3]:  # Mostrar solo los primeros 3
                    text += f"‚Ä¢ {cxc.get('cliente', 'Sin cliente')}: ${cxc.get('monto', 0):,.0f}\n"
                if len(cxc_data) > 3:
                    text += f"... y {len(cxc_data) - 3} m√°s\n"
            else:
                text += "No hay cuentas por cobrar.\n"
            
            text += "\nüìâ **Cuentas por Pagar:**\n"
            if cxp_data:
                total_cxp = sum(item.get('monto', 0) for item in cxp_data)
                text += f"Total: ${total_cxp:,.0f}\n"
                for cxp in cxp_data[:3]:  # Mostrar solo los primeros 3
                    text += f"‚Ä¢ {cxp.get('proveedor', 'Sin proveedor')}: ${cxp.get('monto', 0):,.0f}\n"
                if len(cxp_data) > 3:
                    text += f"... y {len(cxp_data) - 3} m√°s\n"
            else:
                text += "No hay cuentas por pagar.\n"
            
            text += "\n*En desarrollo*"
            
            keyboard = [[InlineKeyboardButton("üîô Volver al Men√∫", callback_data="back_main")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
        except Exception as e:
            logger.error(f"Error manejando CxC/CxP: {e}")
            await query.edit_message_text("Error obteniendo datos de cuentas.")
    
    @staticmethod
    async def _handle_asesor_ia(query, user_data):
        """Manejar opci√≥n de Asesor IA"""
        text = (
            "ü§ñ **Asesor IA**\n\n"
            "El asesor de inteligencia artificial est√° en desarrollo.\n\n"
            "Pr√≥ximamente podr√°s:\n"
            "‚Ä¢ Hacer preguntas sobre tus datos\n"
            "‚Ä¢ Obtener an√°lisis autom√°ticos\n"
            "‚Ä¢ Recibir recomendaciones\n"
            "‚Ä¢ Generar reportes inteligentes\n\n"
            "*En desarrollo*"
        )
        
        keyboard = [[InlineKeyboardButton("üîô Volver al Men√∫", callback_data="back_main")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
    
    @staticmethod
    async def _handle_agendar(query, user_data):
        """Manejar opci√≥n de agendar (simplificado)"""
        text = (
            "üìÖ **Sistema de Agendamiento**\n\n"
            "El sistema de agendamiento est√° en desarrollo.\n\n"
            "Pr√≥ximamente podr√°s:\n"
            "‚Ä¢ Crear citas y reuniones\n"
            "‚Ä¢ Ver tu calendario\n"
            "‚Ä¢ Recibir recordatorios\n"
            "‚Ä¢ Integrar con sistemas de calendario\n\n"
            "*En desarrollo*"
        )
        
        keyboard = [[InlineKeyboardButton("üîô Volver al Men√∫", callback_data="back_main")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
    
    @staticmethod
    async def _handle_salir(query):
        """Manejar opci√≥n de salir"""
        text = (
            "üëã **¬°Hasta luego!**\n\n"
            "Gracias por usar nuestro sistema.\n"
            "Para volver a usar el bot, env√≠a /start"
        )
        
        await query.edit_message_text(text, parse_mode='Markdown')
    
    @staticmethod
    @log_production_conversation
    async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manejar mensajes de texto del bot de producci√≥n"""
        chat_id = update.effective_chat.id
        message_text = update.message.text
        
        # Validar usuario
        validation = security.validate_user(chat_id)
        
        if not validation['valid']:
            # Registrar usuario no autorizado antes de responder
            await ProductionHandlers._handle_unauthorized_user(update, context)
            return
        
        user_data = validation['user_data']
        
        # El logging ahora es autom√°tico con el decorador
        # Mostrar men√∫ principal
        await ProductionHandlers._show_main_menu(update.message, user_data)
    
    @staticmethod
    @log_unauthorized_access()
    async def _handle_unauthorized_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manejar usuarios no autorizados - REGISTRO AUTOM√ÅTICO"""
        # El decorador @log_unauthorized_access() se encarga de:
        # 1. Registrar usuario en usuarios_detalle 
        # 2. Registrar intento en intentos_acceso_negado
        # 3. Enviar mensaje explicativo
        # 4. NO ejecutar l√≥gica adicional (return None)
        pass
    
    @staticmethod
    async def _handle_ayuda(query, user_data):
        """Manejar opci√≥n de ayuda"""
        text = (
            "‚ÑπÔ∏è *Ayuda del Sistema*\n\n"
            "*Funcionalidades disponibles:*\n\n"
            "üìä *Reportes*: Ver reportes financieros\n"
            "‚è≥ *Pendientes*: Gestionar tareas pendientes\n"
            "üí∞ *CxC & CxP*: Ver cuentas por cobrar y pagar\n"
            "ü§ñ *Asesor IA*: Asesor√≠a inteligente (en desarrollo)\n"
            "üìÖ *Agendar*: Sistema de citas (en desarrollo)\n\n"
            "*Comandos √∫tiles:*\n"
            "‚Ä¢ /start - Mostrar men√∫ principal\n"
            "‚Ä¢ /ayuda - Mostrar esta ayuda\n\n"
            "*Soporte:*\n"
            "Si necesitas ayuda, contacta al administrador o usa el bot√≥n de abajo."
        )
        
        keyboard = [
            [InlineKeyboardButton("ü§ñ Ir a @WingmanBOD", url="https://t.me/WingmanBOD")],
            [InlineKeyboardButton("üîô Volver al Men√∫", callback_data="back_main")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown') 